<!DOCTYPE mapper     PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="io.kontur.layers.repository.LayerMapper">

    <select id="getLayerName" resultType="string">
        select name from layers where public_id = #{publicId}
    </select>

    <select id="getLayers" resultType="io.kontur.layers.repository.model.Layer">
        with lrs as (select l.id,
                          l.public_id as publicid,
                          l.name as name,
                          l.description,
                          l.copyrights,
                          l.properties,
                          l.group_id,
                          l.category_id,
                          l.last_updated as lastupdated,
                          l.source_updated as sourcelastupdated,
                          count(*) OVER() AS numberMatched
                   from layers l
                   where 1 = 1
                   <if test="publicIds != null">
                       <foreach collection="publicIds" item="id" open="and l.public_id in (" separator="," close=")">
                       #{id}
                       </foreach>
                   </if>
                   <if test="geometry != null">
                       and ((l.geom isnull
                                and l.id in (select layer_id
                                            from layers_features ls
                                            where ST_Intersects(ls.geom, ST_SetSRID(ST_GeomFromGeoJSON(#{geometry}), 4326))))
                           or ST_Intersects(l.geom, ST_SetSRID(ST_GeomFromGeoJSON(#{geometry}), 4326)))
                   </if>
                   group by l.id limit #{limit} offset #{offset}),
        ext as (select f.layer_id,
                   st_3dextent(f.geom) as spat,
                   min(f.last_updated) as lowerdt,
                   max(f.last_updated) as upperdt
                   from layers_features f join lrs on lrs.id = f.layer_id
                   group by f.layer_id)
        select lrs.*,
               case when ext.spat is not null then
                    format('[%s,%s,%s,%s,%s,%s]',
                           st_xmin(ext.spat), st_ymin(ext.spat), st_zmin(ext.spat),
                           st_xmax(ext.spat), st_ymax(ext.spat), st_zmax(ext.spat))
               end as spatialextent,
               case when (lowerdt is not null or upperdt is not null ) then
                    tstzrange(lowerdt, upperdt, format('%s%s', '[', ']' ))
               end as temporalextent,
               ls.style_rule as legend,
               json_strip_nulls(json_build_object(
                   'name', gp."name",
                   'is_opened', gp.is_opened,
                   'mutually_exclusive', gp.mutually_exclusive,
                   'order', gp."order")) as group,
               json_strip_nulls(json_build_object(
                   'name', cp."name",
                   'is_opened', cp.is_opened,
                   'mutually_exclusive', cp.mutually_exclusive,
                   'order', cp."order")) as category
        from lrs
            left join ext on lrs.id = ext.layer_id
            left join layers_style ls on ls.layer_id = lrs.id
            left join layers_group_properties gp on gp.id = lrs.group_id
            left join layers_category_properties cp on cp.id = lrs.category_id
    </select>

</mapper>